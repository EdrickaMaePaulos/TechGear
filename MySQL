#include <mysql_driver.h>
#include <mysql_connection.h>
#include <cppconn/statement.h>
#include <cppconn/prepared_statement.h>
#include <cppconn/resultset.h>
#include <cppconn/exception.h>
#include <iostream>
#include <unordered_map>
#include <string>
#include <memory>
#include <cstdlib>
#include <fstream>
#include <sstream>

using namespace std;
using namespace sql;

struct Item {
    string name;
    string category;
    unordered_map<string, string> specs;
    double price;
    int quantity;
    double cost_price;

    Item() : name(""), category(""), price(0.0), quantity(0), cost_price(0.0) {}

    Item(string n, string c, unordered_map<string, string> s, double p, int q, double cp)
        : name(n), category(c), specs(s), price(p), quantity(q), cost_price(cp) {}
};

struct CartNode {
    string item_name;
    CartNode* next;

    CartNode(string name) : item_name(name), next(nullptr) {}
};

class Cart {
private:
    CartNode* head;

public:
    Cart() : head(nullptr) {}

    ~Cart() {
        clear_cart();
    }

    void add_item(const string& item_name) {
        CartNode* newNode = new CartNode(item_name);
        newNode->next = head;
        head = newNode;
    }

    void view_cart() const {
        CartNode* current = head;
        while (current) {
            cout << "- " << current->item_name << "\n";
            current = current->next;
        }
    }

    double total_cost(const unordered_map<string, Item>& inventory) const {
        double total = 0.0;
        CartNode* current = head;
        while (current) {
            total += inventory.at(current->item_name).price;
            current = current->next;
        }
        return total;
    }

    void clear_cart() {
        while (head) {
            CartNode* temp = head;
            head = head->next;
            delete temp;
        }
    }

    CartNode* get_head() const {
        return head;
    }
};

struct PurchaseRecord {
    string item_name;
    double cost;
    string date;

    PurchaseRecord(const string& item, double c, const string& d) : item_name(item), cost(c), date(d) {}
};

struct User {
    string username;
    string password;
    Cart cart;
    double money;
    vector<PurchaseRecord> purchase_history;

    User() : username(""), password(""), money(0.0) {}
};

class UserManager {
private:
    unordered_map<string, User> users;
    const string user_file = "users.txt";
    const string admin_username = "admin";
    const string admin_password = "admin";

    void load_users() {
        ifstream file(user_file);
        if (file.is_open()) {
            string line;
            while (getline(file, line)) {
                istringstream iss(line);
                User user;
                iss >> user.username >> user.password >> user.money;
                users[user.username] = user;
            }
            file.close();
        }
    }

    void save_users() {
        ofstream file(user_file);
        if (file.is_open()) {
            for (const auto& pair : users) {
                file << pair.second.username << " "
                    << pair.second.password << " "
                    << pair.second.money << "\n";
            }
            file.close();
        }
    }

    void save_purchase_history(const string& username) {
        ofstream file(username + "history.txt", ios::app);
        if (file.is_open()) {
            for (const auto& record : users[username].purchase_history) {
                file << "\"" << record.item_name << "\" " << record.cost << " " << record.date << "\n";
            }
            file.close();
        }
        else {
            cerr << "Error: Could not open file for user: " << username << endl;
        }
    }

    void load_purchase_history(const string& username) {
        ifstream file(username + "history.txt");
        if (file.is_open()) {
            string line;
            while (getline(file, line)) {
                istringstream iss(line);
                string item_name;
                double cost;
                string date;

                getline(iss, item_name, '\"');
                getline(iss, item_name, '\"');
                iss >> cost;
                iss.ignore();
                getline(iss, date);

                users[username].purchase_history.emplace_back(item_name, cost, date);
            }
            file.close();
        }
    }

public:
    UserManager() {
        load_users();
    }

    ~UserManager() {
        save_users();
        for (const auto& pair : users) {
            save_purchase_history(pair.first);
        }
    }

    bool register_user(const string& username, const string& password) {
        if (users.find(username) != users.end()) {
            return false;
        }
        User newUser;
        newUser.username = username;
        newUser.password = password;
        newUser.money = 0.0;

        users[username] = newUser;
        save_users();
        return true;
    }

    bool login_user(const string& username, const string& password) {
        if (users.find(username) == users.end()) {
            return false;
        }
        if (users[username].password == password) {
            return true;
        }
        return false;
    }

    bool admin_login(const string& username, const string& password) {
        return username == admin_username && password == admin_password;
    }

    bool add_to_cart(const string& username, const string& item) {
        if (users.find(username) == users.end()) {
            return false;
        }
        users[username].cart.add_item(item);
        return true;
    }

    void view_cart(const string& username) {
        cout << username << "'s Cart:\n";
        users[username].cart.view_cart();
    }

    double get_user_money(const string& username) {
        return users[username].money;
    }

    Cart& get_cart(const string& username) {
        return users[username].cart;
    }

    CartNode* get_cart_head(const string& username) const {
        return users.at(username).cart.get_head();
    }

    void add_money(const string& username, double amount) {
        users[username].money += amount;
        save_users();
    }

    void deduct_money(const string& username, double amount) {
        users[username].money -= amount;
        save_users();
    }

    void clear_cart(const string& username) {
        users[username].cart.clear_cart();
    }

    const unordered_map<string, User>& get_users() const {
        return users;
    }

    void add_to_purchase_history(const string& username, const string& item_name, double cost, const string& date) {
        if (users.find(username) != users.end()) {
            users[username].purchase_history.emplace_back(item_name, cost, date);
            save_purchase_history(username);
        }
        else {
            cerr << "Error: User " << username << " not found." << endl;
        }
    }

    void view_purchase_history(const string& username) {
        if (users.find(username) == users.end()) {
            cout << "User not found.\n";
            return;
        }

        users[username].purchase_history.clear();
        load_purchase_history(username);
        const auto& history = users.at(username).purchase_history;

        if (history.empty()) {
            cout << "\t\t\t" << username << " has no purchase history.\n";
            return;
        }

        double total_cost = 0.0;

        cout << "\t\t\t" << username << "'s Purchase History:\n";

        for (const auto& record : history) {
            cout << "\t\t\t- Item: " << record.item_name << ", Cost: Php" << record.cost << ", Date: " << record.date << "\n";
            total_cost += record.cost;
        }
    }

    void view_all_purchase_history() const {
        bool hasHistory = false;

        for (const auto& pair : users) {
            const string& username = pair.first;
            const auto& history = pair.second.purchase_history;

            if (!history.empty()) {
                cout << "\t\t\t" << username << "'s Purchase History: \n";
                for (const auto& record : history) {
                    cout << "Item: " << record.item_name << ", Cost: Php" << record.cost << ", Date: " << record.date << "\n";
                }
                hasHistory = true;
            }
        }

        if (!hasHistory) {
            cout << "\t\t\tNo purchase histories found for any user.\n";
        }
    }
};


class InventoryManager {
   
public:
    unordered_map<string, Item> inventory;
    double total_profit;
    void view_inventory(Connection* conn) {
        try {
            unique_ptr<Statement> stmt(conn->createStatement());
            unique_ptr<ResultSet> res(stmt->executeQuery("SELECT * FROM inventory"));
            while (res->next()) {
                cout << "Item: " << res->getString("item_name") << ", Quantity: " << res->getInt("quantity") << ", Price: " << res->getDouble("price") << endl;
            }
        }
        catch (SQLException& e) {
            cerr << "Error: " << e.what() << endl;
        }
    }

    void update_inventory(const string& item_name, int quantity) {
        inventory[item_name].quantity -= quantity;
    }

    void add_item(Connection* conn, const string& item_name, int quantity, double cost_price, double sell_price) {
        try {
            unique_ptr<PreparedStatement> pstmt(conn->prepareStatement("INSERT INTO inventory (item_name, quantity, cost_price, sell_price) VALUES (?, ?, ?, ?)"));
            pstmt->setString(1, item_name);
            pstmt->setInt(2, quantity);
            pstmt->setDouble(3, cost_price);
            pstmt->setDouble(4, sell_price);
            pstmt->executeUpdate();
            cout << "Item added successfully!" << endl;
        }
        catch (SQLException& e) {
            cerr << "Error: " << e.what() << endl;
        }
    }

    void delete_item(Connection* conn, const string& item_name) {
        try {
            unique_ptr<PreparedStatement> pstmt(conn->prepareStatement("DELETE FROM inventory WHERE item_name = ?"));
            pstmt->setString(1, item_name);
            pstmt->executeUpdate();
            cout << "Item deleted successfully!" << endl;
        }
        catch (SQLException& e) {
            cerr << "Error: " << e.what() << endl;
        }
    }

    void search_by_spec(const string& spec_key, const string& spec_value) {
        bool found = false;
        for (const auto& pair : inventory) {
            const auto& item = pair.second;
            auto it = item.specs.find(spec_key);
            if (it != item.specs.end() && it->second == spec_value) {
                // Print item details
                found = true;
            }
        }
        if (!found) {
            cout << "No items found with " << spec_key << " = " << spec_value << endl;
        }
    }

    void view_top_selling_items() {
        cout << "Top Selling Items:\n";
        for (const auto& pair : inventory) {
            const auto& item = pair.second;
            cout << "Item: " << item.name << ", Sold Quantity: " << item.quantity << "\n";
        }
    }

    void update_profit(double profit) {
        total_profit += profit;
    }

    double get_total_profit() const {
        return total_profit;
    }

    void restock_item(Connection* conn, const string& item_name, int quantity) {
        try {
            unique_ptr<PreparedStatement> pstmt(conn->prepareStatement("UPDATE inventory SET quantity = quantity + ? WHERE item_name = ?"));
            pstmt->setInt(1, quantity);
            pstmt->setString(2, item_name);
            pstmt->executeUpdate();
            cout << "Item restocked successfully!" << endl;
        }
        catch (SQLException& e) {
            cerr << "Error: " << e.what() << endl;
        }
    }

    void load_inventory() {
        ifstream file("inventory.txt");
        if (file.is_open()) {
            string line;
            while (getline(file, line)) {
                istringstream iss(line);
                string name, category;
                unordered_map<string, string> specs;
                double price;
                int quantity;
                double cost_price;

                iss >> name >> category;
                string spec_line;
                while (getline(iss, spec_line, ';')) {
                    size_t pos = spec_line.find(':');
                    if (pos != string::npos) {
                        string key = spec_line.substr(0, pos);
                        string value = spec_line.substr(pos + 1);
                        specs[key] = value;
                    }
                }
                iss >> price >> quantity >> cost_price;

                inventory[name] = Item(name, category, specs, price, quantity, cost_price);
            }
            file.close();
        }
    }

    void save_inventory() {
        ofstream file("inventory.txt");
        if (file.is_open()) {
            for (const auto& pair : inventory) {
                const auto& item = pair.second;
                file << item.name << " " << item.category << " ";
                for (const auto& spec : item.specs) {
                    file << spec.first << ":" << spec.second << ";";
                }
                file << item.price << " " << item.quantity << " " << item.cost_price << "\n";
            }
            file.close();
        }
    }
};

class Techgear {
private:
    InventoryManager inventory_manager;
    UserManager user_manager;
    unique_ptr<Connection> conn;

public:
    Techgear() {
        try {
            Driver* driver = get_mysql_driver_instance();

            // Using _dupenv_s to get environment variables
            char* db_user = nullptr;
            size_t db_user_len = 0;
            if (_dupenv_s(&db_user, &db_user_len, "DB_USER") != 0 || db_user == nullptr) {
                cerr << "Database user environment variable not set" << endl;
                return;
            }

            char* db_password = nullptr;
            size_t db_password_len = 0;
            if (_dupenv_s(&db_password, &db_password_len, "DB_PASSWORD") != 0 || db_password == nullptr) {
                cerr << "Database password environment variable not set" << endl;
                free(db_user);
                return;
            }

            conn.reset(driver->connect("tcp://localhost:3306", db_user, db_password));
            conn->setSchema("techgear");

            // Free the allocated memory
            free(db_user);
            free(db_password);
        }
        catch (SQLException& e) {
            cerr << "Database connection failed: " << e.what() << endl;
            return;
        }
    }

    void register_user() {
        string username, password;
        cout << "Enter username: ";
        cin >> username;
        cout << "Enter password: ";
        cin >> password;
        if (user_manager.register_user(username, password)) {
            cout << "Registration successful!\n";
        }
        else {
            cout << "Username already exists. Try again.\n";
        }
    }

    void user_login() {
        string username, password;
        cout << "Enter username: ";
        cin >> username;
        cout << "Enter password: ";
        cin >> password;
        if (user_manager.login_user(username, password)) {
            cout << "Login successful!\n";
            user_dashboard(username);
        }
        else {
            cout << "Invalid username or password.\n";
        }
    }

    void admin_login() {
        string username, password;
        cout << "Enter admin username: ";
        cin >> username;
        cout << "Enter admin password: ";
        cin >> password;
        if (user_manager.admin_login(username, password)) {
            cout << "Admin login successful!\n";
            admin_dashboard();
        }
        else {
            cout << "Invalid admin username or password.\n";
        }
    }

    void user_dashboard(const string& username) {
        int choice;
        do {
            cout << "\nUser Dashboard:\n";
            cout << "1. View Inventory\n";
            cout << "2. Add to Cart\n";
            cout << "3. View Cart\n";
            cout << "4. Checkout\n";
            cout << "5. Add Money\n";
            cout << "6. View Purchase History\n";
            cout << "7. Logout\n";
            cout << "Enter your choice: ";
            cin >> choice;

            switch (choice) {
            case 1:
                inventory_manager.view_inventory(conn.get());
                break;
            case 2: {
                string item_name;
                cout << "Enter item name to add to cart: ";
                cin >> item_name;
                if (user_manager.add_to_cart(username, item_name)) {
                    cout << "Item added to cart.\n";
                }
                else {
                    cout << "Item not found.\n";
                }
                break;
            }
            case 3:
                user_manager.view_cart(username);
                break;
            case 4:
                checkout(username);
                break;
            case 5: {
                double amount;
                cout << "Enter amount to add: ";
                cin >> amount;
                user_manager.add_money(username, amount);
                cout << "Money added successfully.\n";
                break;
            }
            case 6:
                user_manager.view_purchase_history(username);
                break;
            case 7:
                cout << "Logging out...\n";
                break;
            default:
                cout << "Invalid choice. Try again.\n";
            }
        } while (choice != 7);
    }

    void admin_dashboard() {
        int choice;
        do {
            cout << "\nAdmin Dashboard:\n";
            cout << "1. View Inventory\n";
            cout << "2. Add Item to Inventory\n";
            cout << "3. Delete Item from Inventory\n";
            cout << "4. Restock Item\n";
            cout << "5. View Purchase History\n";
            cout << "6. View All Purchase Histories\n";
            cout << "7. View Total Profit\n";
            cout << "8. Logout\n";
            cout << "Enter your choice: ";
            cin >> choice;

            switch (choice) {
            case 1:
                inventory_manager.view_inventory(conn.get());
                break;
            case 2: {
                string item_name;
                int quantity;
                double cost_price, sell_price;
                cout << "Enter item name: ";
                cin >> item_name;
                cout << "Enter quantity: ";
                cin >> quantity;
                cout << "Enter cost price: ";
                cin >> cost_price;
                cout << "Enter selling price: ";
                cin >> sell_price;
                inventory_manager.add_item(conn.get(), item_name, quantity, cost_price, sell_price);
                break;
            }
            case 3: {
                string item_name;
                cout << "Enter item name to delete: ";
                cin >> item_name;
                inventory_manager.delete_item(conn.get(), item_name);
                break;
            }
            case 4: {
                string item_name;
                int quantity;
                cout << "Enter item name to restock: ";
                cin >> item_name;
                cout << "Enter quantity: ";
                cin >> quantity;
                inventory_manager.restock_item(conn.get(), item_name, quantity);
                break;
            }
            case 5: {
                string username;
                cout << "Enter username to view purchase history: ";
                cin >> username;
                user_manager.view_purchase_history(username);
                break;
            }
            case 6:
                user_manager.view_all_purchase_history();
                break;
            case 7:
                cout << "Total Profit: Php" << inventory_manager.get_total_profit() << "\n";
                break;
            case 8:
                cout << "Logging out...\n";
                break;
            default:
                cout << "Invalid choice. Try again.\n";
            }
        } while (choice != 8);
    }

    void checkout(const string& username) {
        CartNode* current = user_manager.get_cart_head(username);
        double total_cost = 0.0;
        while (current) {
            total_cost += inventory_manager.inventory.at(current->item_name).price;
            current = current->next;
        }

        if (total_cost > user_manager.get_user_money(username)) {
            cout << "Insufficient funds.\n";
            return;
        }

        current = user_manager.get_cart_head(username);
        while (current) {
            const Item& item = inventory_manager.inventory.at(current->item_name);
            if (item.quantity > 0) {
                inventory_manager.update_inventory(item.name, 1);
                inventory_manager.update_profit(item.price - item.cost_price);
                user_manager.deduct_money(username, item.price);
                user_manager.add_to_purchase_history(username, item.name, item.price, __DATE__);
            }
            else {
                cout << "Item " << item.name << " is out of stock.\n";
            }
            current = current->next;
        }
        user_manager.clear_cart(username);
        cout << "Checkout complete.\n";
    }
};

int main() {
    Techgear techgear;
    int choice;
    do {
        cout << "1. Register\n";
        cout << "2. User Login\n";
        cout << "3. Admin Login\n";
        cout << "4. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            techgear.register_user();
            break;
        case 2:
            techgear.user_login();
            break;
        case 3:
            techgear.admin_login();
            break;
        case 4:
            cout << "Exiting...\n";
            break;
        default:
            cout << "Invalid choice. Try again.\n";
        }
    } while (choice != 4);

    return 0;
}
